/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/+
Port of Bullet Physics to D
+/

public import bullet.linearMath.btScalar;
public import bullet.linearMath.btMinMax;

version(__SPU__) {
	version(__CELLOS_LV2__) {
		version = SPU_AND_CELLOS;
	}
}

/**@brief The btQuadWord class is base class for btVector3 and btQuaternion. 
 * Some issues under PS3 Linux with IBM 2.1 SDK, gcc compiler prevent from using aligned quadword.
 */
/+The selection of alignment by preprocessor had to be removed because D
doesn't have a preprocessor and it didn't seem worth it to copy the class
for the conditional compilation system. I don't think D works on yet PS3 anyway.
#ifndef USE_LIBSPE2
ATTRIBUTE_ALIGNED16(class) btQuadWord
#else
class btQuadWord
#endif
+/
struct btQuadWord
{

version(SPU_AND_CELLOS) {
	union {
		vec_float4 mVec128;
		btScalar	m_floats[4];
	};
	vec_float4	get128() const
	{
		return mVec128;
	}
} else {
	btScalar	m_floats[4];
}
  

  /**@brief Return the x value */
		const btScalar getX() const { return m_floats[0]; }
  /**@brief Return the y value */
		const btScalar getY() const { return m_floats[1]; }
  /**@brief Return the z value */
		const btScalar getZ() const { return m_floats[2]; }
  /**@brief Set the x value */
		void	setX(btScalar x) { m_floats[0] = x;};
  /**@brief Set the y value */
		void	setY(btScalar y) { m_floats[1] = y;};
  /**@brief Set the z value */
		void	setZ(btScalar z) { m_floats[2] = z;};
  /**@brief Set the w value */
		void	setW(btScalar w) { m_floats[3] = w;};
  /**@brief Return the x value */
		const btScalar x() const { return m_floats[0]; }
  /**@brief Return the y value */
		const btScalar y() const { return m_floats[1]; }
  /**@brief Return the z value */
		const btScalar z() const { return m_floats[2]; }
  /**@brief Return the w value */
		const btScalar w() const { return m_floats[3]; }

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}      
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	///operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
	btScalar opCast(T: btScalar)()       { return &m_floats[0]; }
	btScalar opCast(T: btScalar)() const { return &m_floats[0]; }

	bool opEquals()(const auto ref btQuadWord other) const
	{
		return ((m_floats[3]==other.m_floats[3]) && (m_floats[2]==other.m_floats[2]) && (m_floats[1]==other.m_floats[1]) && (m_floats[0]==other.m_floats[0]));
	}
	//operator!= is automatically generated by the D compiler

  /**@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
		void 	setValue()(const auto ref btScalar x, const auto ref btScalar y, const auto ref btScalar z)
		{
			m_floats[0]=x;
			m_floats[1]=y;
			m_floats[2]=z;
			m_floats[3] = 0.f;
		}

/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] = m_floats[2];
		}
*/
/**@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
		void	setValue()(const auto ref btScalar x, const auto ref btScalar y, const auto ref btScalar z,const auto ref btScalar w)
		{
			m_floats[0]=x;
			m_floats[1]=y;
			m_floats[2]=z;
			m_floats[3]=w;
		}
  /**@brief No initialization constructor */
		//Not allowed in D
		//btQuadWord() {}
 
  /**@brief Three argument constructor (zeros w)
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
		this()(const auto ref btScalar x, const auto ref btScalar y, const auto ref btScalar z)		
		{
			m_floats[0] = x, m_floats[1] = y, m_floats[2] = z, m_floats[3] = 0.0f;
		}

/**@brief Initializing constructor
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
		this()(const auto ref btScalar x, const auto ref btScalar y, const auto ref btScalar z,const auto ref btScalar w) 
		{
			m_floats[0] = x, m_floats[1] = y, m_floats[2] = z, m_floats[3] = w;
		}

  /**@brief Set each element to the max of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
		void	setMax()(const auto ref btQuadWord other)
		{
			btSetMax(m_floats[0], other.m_floats[0]);
			btSetMax(m_floats[1], other.m_floats[1]);
			btSetMax(m_floats[2], other.m_floats[2]);
			btSetMax(m_floats[3], other.m_floats[3]);
		}
  /**@brief Set each element to the min of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
		void	setMin()(const auto ref btQuadWord other)
		{
			btSetMin(m_floats[0], other.m_floats[0]);
			btSetMin(m_floats[1], other.m_floats[1]);
			btSetMin(m_floats[2], other.m_floats[2]);
			btSetMin(m_floats[3], other.m_floats[3]);
		}



};
